// Reference: Lecture slides and quiz 6 from Module 5 (Justus)
#include <iostream>
#include <vector>
#include <string>
#include <unordered_set>
#include <fstream>
#include <sstream>
#include <chrono>
using namespace std;

// SongNode class (Maya)
struct SongNode {
  public:
    string title;
    string artist;
    SongNode(string t, string a) {
      title = t;
      artist = a;
    }
};

// set data structure (Maya)
struct SongSet {
private:
    unordered_set<pair<SongNode, int>> songs;
public:
    SongSet() {}
    void add(SongNode song) {
        bool found = false;
        unordered_set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->first.title == song.title && itr->first.artist == song.artist) {
                found = true;
                break;
            }
        }
        if(!found) {
            pair<SongNode, int> p(song, 0);
            songs.insert(p);
        }
    }
    void remove(SongNode song) {
        unordered_set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->first.title == song.title && itr->first.artist == song.artist) {
                songs.erase(itr);
                break;
            }
        }
    }
    void play(SongNode song) {
        unordered_set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->first.title == song.title && itr->first.artist == song.artist) {
                int newNum = itr->second + 1;
                pair<SongNode, int> p(song, newNum);
                songs.erase(itr);
                songs.insert(p);
                break;
            }
        }
    }
    vector<SongNode> getMostPopular() {
        unordered_set<pair<SongNode, int>>::iterator itr;
        unordered_set<pair<SongNode, int>>::iterator itr2 = songs.begin();
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second > itr2->second) {
                itr2 = itr;
            }
        }
        vector<SongNode> popular;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second == itr2->second) {
                popular.push_back(itr->first);
            }
        }
        return popular;
    }
    vector<SongNode> getLeastPopular() {
        unordered_set<pair<SongNode, int>>::iterator itr;
        unordered_set<pair<SongNode, int>>::iterator itr2 = songs.begin();
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second < itr2->second) {
                itr2 = itr;
            }
        }
        vector<SongNode> notPopular;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second == itr2->second) {
                notPopular.push_back(itr->first);
            }
        }
        return notPopular;
    }
    void printSong(SongNode song) {
        cout << "Title: " << song.title << endl << "Artist: " << song.artist << endl;
    }
    void printTop(int n) {
        SongSet newS = SongSet();
        unordered_set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            newS.songs.insert(make_pair(itr->first,itr->second));
        }
        int count = 0;
        while(count < n) {
            vector<SongNode> mostCurr = newS.getMostPopular();
            for(int i = 0; i < mostCurr.size(); i++) {
                newS.printSong(mostCurr[i]);
                count++;
                newS.remove(mostCurr[i]);
            }
        }
    }
};

// priority queue data structure (Justus)
struct SongPQNode {

private:

    vector<pair<string,string>> songPQ;
    vector<pair<string,string>> songFrequency;
    vector<int> highestPlayedSong;


public:

    SongPQNode() {}

    void insertSong(SongNode s) {

        int priorityLevel = 0;

        if(songPQ.empty()) {

            songPQ.push_back(make_pair(s.title, s.artist));
            songFrequency.push_back(make_pair(s.title, s.artist));

            if(highestPlayedSong.empty()) {

                priorityLevel = count(songPQ.begin(), songPQ.end(), songPQ[0]);

                highestPlayedSong.push_back(priorityLevel);
            }

        }
        else {


            songPQ.push_back(make_pair(s.title, s.artist));
            songFrequency.push_back(make_pair(s.title, s.artist));

            for(int i = 0; i < songPQ.size(); i++) {

                if(s.title == songPQ[i].first && s.artist == songPQ[i].second) {

                    priorityLevel = count(songFrequency.begin(), songFrequency.end(), songPQ[i]);

                    if(priorityLevel > 1) {

                        highestPlayedSong[i] = priorityLevel;

                        songPQ.pop_back();
                    }
                    else {

                        highestPlayedSong.push_back(priorityLevel);
                                                                    
                    }

                    break;
                }

            }


            int childSong = songPQ.size() - 1;
            int parentSong = ((childSong - 1) / 2);


            if(parentSong >= 0 && highestPlayedSong[parentSong] == highestPlayedSong[childSong]) {}
            else {

                while (parentSong >= 0 && highestPlayedSong[parentSong] < highestPlayedSong[childSong]) {

                    string tempTitle = songPQ[parentSong].first;
                    string tempArtist = songPQ[parentSong].second;

                    songPQ[parentSong].first = songPQ[childSong].first;
                    songPQ[parentSong].second = songPQ[childSong].second;

                    songPQ[childSong].first = tempTitle;
                    songPQ[childSong].second = tempArtist;

                    childSong = parentSong;
                    parentSong = ((childSong - 1) / 2);


                }
            }

        }

    }


    void extractHighestPrioritySong(SongNode s) {

        if(songPQ.size() == 2) {

            songPQ[0].first = songPQ[songPQ.size()-1].first;
            songPQ[0].second = songPQ[songPQ.size()-1].second;

        }
        else {

            int childSong = songPQ.size() - 1;
            int parentSong = ((childSong - 1) / 2);

            int leftChildSong = (2*parentSong) + 1;
            int rightChildSong = (2*parentSong) + 2;

            songPQ[parentSong].first = songPQ[songPQ.size()-1].first;
            songPQ[parentSong].second = songPQ[songPQ.size()-1].second;


            if(highestPlayedSong[parentSong] < highestPlayedSong[leftChildSong] && highestPlayedSong[leftChildSong] > highestPlayedSong[rightChildSong]) {

                string tempTitle = songPQ[parentSong].first;
                string tempArtist = songPQ[parentSong].second;

                songPQ[parentSong].first = songPQ[leftChildSong].first;
                songPQ[parentSong].second = songPQ[leftChildSong].second;

                songPQ[leftChildSong].first = tempTitle ;
                songPQ[leftChildSong].second = tempArtist;

                parentSong = leftChildSong;

                leftChildSong = (2*parentSong) + 1;
                rightChildSong = (2*parentSong) + 2;

                while(rightChildSong <= childSong) {

                    if(highestPlayedSong[parentSong] < highestPlayedSong[leftChildSong] && highestPlayedSong[leftChildSong] > highestPlayedSong[rightChildSong]) {

                        tempTitle = songPQ[parentSong].first;
                        tempArtist = songPQ[parentSong].second;

                        songPQ[parentSong].first = songPQ[leftChildSong].first;
                        songPQ[parentSong].second = songPQ[leftChildSong].second;

                        songPQ[leftChildSong].first = tempTitle ;
                        songPQ[leftChildSong].second = tempArtist;

                        parentSong = leftChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;


                    }
                    else if(highestPlayedSong[parentSong] < highestPlayedSong[rightChildSong] && highestPlayedSong[rightChildSong] > highestPlayedSong[leftChildSong]) {

                        tempTitle = songPQ[parentSong].first;
                        tempArtist = songPQ[parentSong].second;

                        songPQ[parentSong].first = songPQ[rightChildSong].first;
                        songPQ[parentSong].second = songPQ[rightChildSong].second;

                        songPQ[rightChildSong].first = tempTitle ;
                        songPQ[rightChildSong].second = tempArtist;

                        parentSong = rightChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;

                    }



                }



            }
            else if(highestPlayedSong[parentSong] < highestPlayedSong[rightChildSong] && highestPlayedSong[rightChildSong] > highestPlayedSong[leftChildSong]) {

                string tempTitle = songPQ[parentSong].first;
                string tempArtist = songPQ[parentSong].second;

                songPQ[parentSong].first = songPQ[rightChildSong].first;
                songPQ[parentSong].second = songPQ[rightChildSong].second;

                songPQ[rightChildSong].first = tempTitle ;
                songPQ[rightChildSong].second = tempArtist;

                parentSong = rightChildSong;

                leftChildSong = (2*parentSong) + 1;
                rightChildSong = (2*parentSong) + 2;

                while(rightChildSong <= childSong) {

                    if(highestPlayedSong[parentSong] < highestPlayedSong[leftChildSong] && highestPlayedSong[leftChildSong] > highestPlayedSong[rightChildSong]) {

                        tempTitle = songPQ[parentSong].first;
                        tempArtist = songPQ[parentSong].second;

                        songPQ[parentSong].first = songPQ[leftChildSong].first;
                        songPQ[parentSong].second = songPQ[leftChildSong].second;

                        songPQ[leftChildSong].first = tempTitle ;
                        songPQ[leftChildSong].second = tempArtist;

                        parentSong = leftChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;


                    }
                    else if(highestPlayedSong[parentSong] < highestPlayedSong[rightChildSong] && highestPlayedSong[rightChildSong] > highestPlayedSong[leftChildSong]) {

                        tempTitle = songPQ[parentSong].first;
                        tempArtist = songPQ[parentSong].second;

                        songPQ[parentSong].first = songPQ[rightChildSong].first;
                        songPQ[parentSong].second = songPQ[rightChildSong].second;

                        songPQ[rightChildSong].first = tempTitle ;
                        songPQ[rightChildSong].second = tempArtist;

                        parentSong = rightChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;

                    }



                }


            }



        }

    }

    void printSong(SongNode song) {

        cout << "Title: " << song.title << endl << "Artist: " << song.artist << endl;
    }

    void mostPopularSong() {

        cout << "Title: " << songPQ[0].first << endl;
        cout << "Artist: " << songPQ[0].second << endl;
        
    }

    void leastPopularSong() {

        cout << "Title: " << songPQ[songPQ.size()-1].first << endl;
        cout << "Artist: " << songPQ[songPQ.size()-1].second << endl;
    }




};

// main implementation (Derek)
void ReadCSVSet(SongSet& songs, string filename) {
    fstream songReader;
    songReader.open(filename, ios::in);
    string line;
    string tempName;
    string tempArtist;
    string waste;

    if (songReader.is_open()) {
        while (getline(songReader, line)) {
            stringstream str(line);
            //Skip ID value
            getline(str, waste, ',');
            //Grab track name
            getline(str, tempName, ',');
            //Skip popularity, duration, and explicit values
            for (int i = 0; i < 3; i++) {
                getline(str, waste, ',');
            }
            //Grab artist name
            getline(str, tempArtist, ',');
            //Create SongNode and add it to Set
            songs.add(SongNode(tempName, tempArtist));
        }
    }
    else {
        cout << "Coud not open the file. << endl";
    }
}

// main implementation (Derek)
int main() {
    //Create Set 
    //SongSet SetofSongs = new SongSet();
    SongSet SetofSongs;

    //Add songs from data set to SongSet (and time how long it takes)
    string filename = "tracks.csv";
    auto start = chrono::steady_clock::now();
    ReadCSVSet(SetofSongs, filename);
    auto end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for inserting songs into Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Time Algorithms of Set of Songs
    //Play song from set:
    SongNode sampleSong("Stay With Me", "['Akcent']");
    start = chrono::steady_clock::now();
    SetofSongs.play(sampleSong);
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for playing song from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Get most popular song from set:
    start = chrono::steady_clock::now();
    vector<SongNode> mostPopularfromSet = SetofSongs.getMostPopular();
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for getting most popular song(s) from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Get least popular song(s) from set:
    start = chrono::steady_clock::now();
    vector<SongNode> LeastPopularfromSet = SetofSongs.getLeastPopular();
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for getting least popular song(s) from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Print Song
    start = chrono::steady_clock::now();
    SetofSongs.printSong(sampleSong);
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for printing song from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;


    //Print Top N Songs (50 for this example)
    int n = 50;
    start = chrono::steady_clock::now();
    SetofSongs.printTop(n);
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for printing top 50 songs from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Delete Song from Set:
    start = chrono::steady_clock::now();
    SetofSongs.remove(sampleSong);
    end = chrono::steady_clock::now();
    cout << "Elapsed time in seconds for removing a song from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Create Priority Queue

    return 0;
}

// Reference: Lecture slides and quiz 6 from Module 5 (Justus)
#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <fstream>
#include <sstream>
#include <chrono>
using namespace std;

// SongNode class (Maya)
struct SongNode {
  public:
    string title;
    string artist;
    SongNode(string t, string a) {
      title = t;
      artist = a;
    }
};

// set data structure (Maya)
struct SongSet {
private:
    set<pair<SongNode, int>> songs;
public:
    SongSet() {}
    void add(SongNode song) {
        bool found = false;
        set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->first.title == song.title && itr->first.artist == song.artist) {
                found = true;
                break;
            }
        }
        if(!found) {
            pair<SongNode, int> p(song, 0);
            songs.insert(p);
        }
    }
    void remove(SongNode song) {
        set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->first.title == song.title && itr->first.artist == song.artist) {
                songs.erase(itr);
                break;
            }
        }
    }
    void play(SongNode song) {
        set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->first.title == song.title && itr->first.artist == song.artist) {
                int newNum = itr->second + 1;
                pair<SongNode, int> p(song, newNum);
                songs.erase(itr);
                songs.insert(p);
                break;
            }
        }
    }
    vector<SongNode> getMostPopular() {
        set<pair<SongNode, int>>::iterator itr;
        set<pair<SongNode, int>>::iterator itr2 = songs.begin();
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second > itr2->second) {
                itr2 = itr;
            }
        }
        vector<SongNode> popular;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second == itr2->second) {
                popular.push_back(itr->first);
            }
        }
        return popular;
    }
    vector<SongNode> getLeastPopular() {
        set<pair<SongNode, int>>::iterator itr;
        set<pair<SongNode, int>>::iterator itr2 = songs.begin();
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second < itr2->second) {
                itr2 = itr;
            }
        }
        vector<SongNode> notPopular;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            if(itr->second == itr2->second) {
                notPopular.push_back(itr->first);
            }
        }
        return notPopular;
    }
    void printSong(SongNode song) {
        cout << "Title: " << song.title << endl << "Artist: " << song.artist << endl;
    }
    void printTop(int n) {
        SongSet newS = SongSet();
        set<pair<SongNode, int>>::iterator itr;
        for(itr = songs.begin(); itr != songs.end(); itr++) {
            newS.songs.insert(make_pair(itr->first,itr->second));
        }
        int count = 0;
        while(count < n) {
            vector<SongNode> mostCurr = newS.getMostPopular();
            for(int i = 0; i < mostCurr.size(); i++) {
                newS.printSong(mostCurr[i]);
                count++;
                newS.remove(mostCurr[i]);
            }
        }
    }
};

// priority queue data structure (Justus)
struct SongPQNode {

private:

    vector<SongNode> songPQ;
    vector<int> highestPlayedSong;

public:

    SongPQNode() {}

    void insertSong(vector<SongNode>& songs, SongNode s) {

        SongNode currentSong = s;
        int priorityLevel = 0;

        if(songs.empty()) {

            songPQ.push_back(currentSong);

            if(highestPlayedSong.empty()) {

                priorityLevel = count(songPQ.begin(), songPQ.end(), currentSong);

                highestPlayedSong.push_back(priorityLevel);
            }

        }
        else {

            auto iter = find(songPQ.begin(), songPQ.end(), currentSong);

            if(iter != songPQ.end()) {

                songPQ.push_back(currentSong);

                for(int i = 0; i < songPQ.size(); i++) {

                    if(currentSong.title == songPQ[i].title && currentSong.artist == songPQ[i].artist) {

                        priorityLevel = count(songPQ.begin(), songPQ.end(), currentSong);

                        highestPlayedSong[i] = priorityLevel;

                        break;
                    }
                }
            }
            else {

                songPQ.push_back(currentSong);

                for(int i = 0; i < songPQ.size(); i++) {

                    if(currentSong.title == songPQ[i].title && currentSong.artist == songPQ[i].artist) {

                        priorityLevel = count(songPQ.begin(), songPQ.end(), currentSong);

                        highestPlayedSong[i] = priorityLevel;

                        break;

                    }
                    else {

                        priorityLevel = count(songPQ.begin(), songPQ.end(), currentSong);

                        highestPlayedSong.push_back(priorityLevel);

                    }
                }
            }


            int childSong = songPQ.size() - 1;
            int parentSong = ((childSong - 1) / 2);


            if(parentSong >= 0 && highestPlayedSong[parentSong] == highestPlayedSong[childSong]) {}
            else {

                while (parentSong >= 0 && highestPlayedSong[parentSong] < highestPlayedSong[childSong]) {

                    string tempTitle = songPQ[parentSong].title;
                    string tempArtist = songPQ[parentSong].artist;

                    songPQ[parentSong].title = songPQ[childSong].title;
                    songPQ[parentSong].artist = songPQ[childSong].artist;

                    songPQ[childSong].title = tempTitle;
                    songPQ[childSong].artist = tempArtist;

                    childSong = parentSong;
                    parentSong = ((childSong - 1) / 2);


                }
            }





        }



    }


    void extractHighestPlayedSong(vector<SongNode>& songs) {

        if(songs.size() == 2) {

            songPQ[0].title = songPQ[songs.size()-1].title;
            songPQ[0].artist = songPQ[songs.size()-1].artist;

        }
        else {

            int childSong = songPQ.size() - 1;
            int parentSong = ((childSong - 1) / 2);

            int leftChildSong = (2*parentSong) + 1;
            int rightChildSong = (2*parentSong) + 2;

            songPQ[parentSong].title = songPQ[songs.size()-1].title;
            songPQ[parentSong].artist = songPQ[songs.size()-1].artist;


            if(highestPlayedSong[parentSong] < highestPlayedSong[leftChildSong] && highestPlayedSong[leftChildSong] > highestPlayedSong[rightChildSong]) {

                string tempTitle = songPQ[parentSong].title;
                string tempArtist = songPQ[parentSong].artist;

                songPQ[parentSong].title = songPQ[leftChildSong].title;
                songPQ[parentSong].artist = songPQ[leftChildSong].artist;

                songPQ[leftChildSong].title = tempTitle ;
                songPQ[leftChildSong].artist = tempArtist;

                parentSong = leftChildSong;

                leftChildSong = (2*parentSong) + 1;
                rightChildSong = (2*parentSong) + 2;

                while(rightChildSong <= childSong) {

                    if(highestPlayedSong[parentSong] < highestPlayedSong[leftChildSong] && highestPlayedSong[leftChildSong] > highestPlayedSong[rightChildSong]) {

                        tempTitle = songPQ[parentSong].title;
                        tempArtist = songPQ[parentSong].artist;

                        songPQ[parentSong].title = songPQ[leftChildSong].title;
                        songPQ[parentSong].artist = songPQ[leftChildSong].artist;

                        songPQ[leftChildSong].title = tempTitle ;
                        songPQ[leftChildSong].artist = tempArtist;

                        parentSong = leftChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;


                    }
                    else if(highestPlayedSong[parentSong] < highestPlayedSong[rightChildSong] && highestPlayedSong[rightChildSong] > highestPlayedSong[leftChildSong]) {

                        tempTitle = songPQ[parentSong].title;
                        tempArtist = songPQ[parentSong].artist;

                        songPQ[parentSong].title = songPQ[rightChildSong].title;
                        songPQ[parentSong].artist = songPQ[rightChildSong].artist;

                        songPQ[rightChildSong].title = tempTitle ;
                        songPQ[rightChildSong].artist = tempArtist;

                        parentSong = rightChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;

                    }



                }



            }
            else if(highestPlayedSong[parentSong] < highestPlayedSong[rightChildSong] && highestPlayedSong[rightChildSong] > highestPlayedSong[leftChildSong]) {

                string tempTitle = songPQ[parentSong].title;
                string tempArtist = songPQ[parentSong].artist;

                songPQ[parentSong].title = songPQ[rightChildSong].title;
                songPQ[parentSong].artist = songPQ[rightChildSong].artist;

                songPQ[rightChildSong].title = tempTitle ;
                songPQ[rightChildSong].artist = tempArtist;

                parentSong = rightChildSong;

                leftChildSong = (2*parentSong) + 1;
                rightChildSong = (2*parentSong) + 2;

                while(rightChildSong <= childSong) {

                    if(highestPlayedSong[parentSong] < highestPlayedSong[leftChildSong] && highestPlayedSong[leftChildSong] > highestPlayedSong[rightChildSong]) {

                        tempTitle = songPQ[parentSong].title;
                        tempArtist = songPQ[parentSong].artist;

                        songPQ[parentSong].title = songPQ[leftChildSong].title;
                        songPQ[parentSong].artist = songPQ[leftChildSong].artist;

                        songPQ[leftChildSong].title = tempTitle ;
                        songPQ[leftChildSong].artist = tempArtist;

                        parentSong = leftChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;


                    }
                    else if(highestPlayedSong[parentSong] < highestPlayedSong[rightChildSong] && highestPlayedSong[rightChildSong] > highestPlayedSong[leftChildSong]) {

                        tempTitle = songPQ[parentSong].title;
                        tempArtist = songPQ[parentSong].artist;

                        songPQ[parentSong].title = songPQ[rightChildSong].title;
                        songPQ[parentSong].artist = songPQ[rightChildSong].artist;

                        songPQ[rightChildSong].title = tempTitle ;
                        songPQ[rightChildSong].artist = tempArtist;

                        parentSong = rightChildSong;

                        leftChildSong = (2*parentSong) + 1;
                        rightChildSong = (2*parentSong) + 2;

                    }



                }


            }



        }

    }

    void printSong(SongNode song) {

        cout << "Title: " << song.title << endl << "Artist: " << song.artist << endl;
    }

    void mostPopularSong(vector<SongNode>& songs) {

        cout << "Title: " << songs[0].title << endl;
        cout << "Artist: " << songs[0].artist << endl;
    }

    void leastPopularSong(vector<SongNode>& songs) {

        cout << "Title: " << songs[songs.size()-1].title << endl;
        cout << "Artist: " << songs[songs.size()-1].artist << endl;
    }




};

// main implementation (Derek)
void ReadCSVSet(SongSet& songs, string filename) {
    fstream songReader;
    songReader.open(filename, ios::in);
    string line;
    string tempName;
    string tempArtist;
    string waste;

    if (songReader.is_open()) {
        while (getline(songReader, line)) {
            stringstream str(line);
            //Skip ID value
            getline(str, waste, ',');
            //Grab track name
            getline(str, tempName, ',');
            //Skip popularity, duration, and explicit values
            for (int i = 0; i < 3; i++) {
                getline(str, waste, ',');
            }
            //Grab artist name
            getline(str, tempArtist, ',');
            //Create SongNode and add it to Set
            songs.add(SongNode(tempName, tempArtist));
        }
    }
    else {
        cout << "Coud not open the file. << endl";
    }
}

// main implementation (Derek)
int main() {
    //Create Set 
    //SongSet SetofSongs = new SongSet();
    SongSet SetofSongs;

    //Add songs from data set to SongSet (and time how long it takes)
    string filename = "tracks.csv";
    auto start = chrono::steady_clock::now();
    ReadCSVSet(SetofSongs, filename);
    auto end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for inserting songs into Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Time Algorithms of Set of Songs
    //Play song from set:
    SongNode sampleSong("Stay With Me", "['Akcent']");
    start = chrono::steady_clock::now();
    SetofSongs.play(sampleSong);
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for playing song from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Get most popular song from set:
    start = chrono::steady_clock::now();
    vector<SongNode> mostPopularfromSet = SetofSongs.getMostPopular();
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for getting most popular song(s) from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Get least popular song(s) from set:
    start = chrono::steady_clock::now();
    vector<SongNode> LeastPopularfromSet = SetofSongs.getLeastPopular();
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for getting least popular song(s) from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Print Song
    start = chrono::steady_clock::now();
    SetofSongs.printSong(sampleSong);
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for printing song from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;


    //Print Top N Songs (50 for this example)
    int n = 50;
    start = chrono::steady_clock::now();
    SetofSongs.printTop(n);
    end = chrono::steady_clock::now();

    cout << "Elapsed time in seconds for printing top 50 songs from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Delete Song from Set:
    start = chrono::steady_clock::now();
    SetofSongs.remove(sampleSong);
    end = chrono::steady_clock::now();
    cout << "Elapsed time in seconds for removing a song from Set: " << chrono::duration_cast<chrono::seconds>(end - start).count() << " seconds" << endl;

    //Create Priority Queue

    return 0;
}
